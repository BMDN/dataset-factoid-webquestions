#!/usr/bin/python -u
#
# Generates dataset of question IDs and with freebase kyes for each question concept provided in question dump
#
# Usage: generate-dataset.py apikey dump.json keys.json [relpaths.json]
#
# Apikey is the key for google freebase api and can be obtained here: https://console.developers.google.com/
# File dump.json needs to contain array of objetcs for each question. Each object needs to have following fields:
# relPath, qId and Concepts. This file can be generated by YodaQa command ./gradlew questionDump.
# File keys.json contains qId and freebaseKey and could be generated by frebaseKeys-from-concepts.py script.
# File relpaths.json needs to be provided if the dump.json does not contain rePaths array.

from __future__ import print_function
import sys, json
from urllib2 import urlopen
import copy

apikey = sys.argv[1]

def walk_node(node, pathprefix, labels):
    relpaths = []
    for name, val in node['property'].items():
        for value in val['values']:
            if value['text'] in labels:
                relpaths.append(tuple(pathprefix + [name]))
            if 'property' in value:
                relpaths += walk_node(value, pathprefix + [name], labels)
    return relpaths

def save_json(data, f):
    """ save data in a given file as json, one line per data item """
    print('[', file=f)
    for q in data:
        e = ',' if q != data[-1] else ''
        print(' ' + json.dumps(q) + e, file=f)
    print(']', file=f)

def json_array_to_map(array, key):
    res = {}
    for line in array:
        res[line[key]] = line
    return res 

def find_branch_of_path(key, relpath_map, concept_paths):
    paths = list(set([tuple(path[0]) for path in relpath_map[key]['relPaths']]))
    concept_path = list(set(concept_paths))
    new_paths = []
    for p in paths:        
        if (len(p) < 2):
            continue
        for path in concept_path:            
            if len(path) < 2:
                continue
            flag = False
            for node in path:
                if node in p:
                    flag = True            
            if flag:                 
                new_paths.append(path) 
    return new_paths  

def merge_paths(key, relpaths_map, dataset_map, new_paths):
    line = relpaths_map[key]
    line2 = dataset_map[key]
    line['LAT'] = line2['LAT']
    line['SV'] = line2['SV']
    for new in new_paths:
        for i, p in enumerate(line['relPaths']):
            if new[0] in p[0]: 
                if (len(line['relPaths'][i][0]) == 2):
                    line['relPaths'][i][0].append(new[1])
                elif (len(line['relPaths'][i][0]) == 3):
                    tmp = copy.deepcopy(line['relPaths'][i])
                    if (tmp[0][2] != new[1]):
                        tmp[0][2] = new[1]
                        line['relPaths'].append(tmp)
    return line


with open(sys.argv[2]) as f:
    dataset = json.load(f)
    
with open(sys.argv[3]) as f:
    keys = json.load(f)

if (len(sys.argv) > 4):
    with open(sys.argv[4]) as f:
        relPaths = json.load(f)
else:
    relPaths = dataset

relpath_map = json_array_to_map(relPaths, 'qId')
dataset_map = json_array_to_map(dataset, 'qId')

print ("[")
for i, line in enumerate(dataset):
    id = line['qId']
    concepts = [key['concept'] for key in keys[i]['mid']]
    key_list = [val for sublist in [key['key'] for key in keys[i]['mid']] for val in sublist]
    concept_paths = [] 
    for k in key_list:
        url = 'https://www.googleapis.com/freebase/v1/topic/m/' + k.split(".")[1]
        urlresp = urlopen(url + '?key=' + apikey)
        resp = json.loads(urlresp.read().decode('utf-8'))
        concept_paths.extend(walk_node(resp, [], concepts))
    concept_paths = list(set(concept_paths))  
    new = find_branch_of_path(id, relpath_map, concept_paths)
    merged = merge_paths(id, relpath_map, dataset_map, new)
    if (i+1 != len(dataset)):
        print(json.dumps(merged) + ",")
    else:
        print(json.dumps(merged))
print("]")
